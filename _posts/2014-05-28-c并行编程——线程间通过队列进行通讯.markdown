---
layout: post
title: 'c#并行编程——线程间通过队列进行通讯'
date: 2014-05-28 13:53:41
tags:
---
C#并行编程，最大的麻烦是线程的控制、线程间的通讯。
线程间通讯之前都是使用lock，但是非常容易死锁，而且性能也不好。
.NET4之后，有几个类，让情况好了很多

线程信号类：相当于通知，触发事件用的，``AutoResetEvent`` ，还有其他的类，个人觉得这个用着简单   
数据集合类：无需锁，即可多线程同时访问``ConcurrentQueue，ConcurrentBag``之类的

有个上面2种工具，我们就可以创造一些工人（线程），他们各自分工，互相通讯，工作起来有条不紊。
请看下面的代码
``` csharp
        private static void NewMethod5()
        {
            ConsoleColor defaultColor = Console.ForegroundColor;
            ConcurrentQueue<int> q = new ConcurrentQueue<int>();//线程通讯用的队列
            AutoResetEvent autoResetEvent = new AutoResetEvent(false);
            Task waitingTask = Task.Factory.StartNew(() =>
            {
                //一个工人，负责接收消息，并写入文件
                while (true)
                {
                    autoResetEvent.WaitOne();//休息一会儿，他们通知我，我再向下运行
                    int res;
                    while (q.TryDequeue(out  res))//只要队列（消息流水线）里有东西，我就不能停
                    {
                        if (res > 999)
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                        }
                        else Console.ForegroundColor = defaultColor;
                        Console.WriteLine("get {0}", res);
                        File.AppendAllText(@"d:\Log\test.log", res.ToString());//只有一个线程向文件写内容，不需要再锁了
                    }
                }
            });
            for (int i = 0; i < 5; i++)
            {
                //5个工人，负责制作数据，并交给消息队列（相当于产品流水线）
                Task.Factory.StartNew(() =>
                {
                    Random rnd = new Random();
                    while (true)
                    {
                        int e = rnd.Next(500, 2000);//产生消息
                        q.Enqueue(e);//放入队列，产品发到流水线上
                        autoResetEvent.Set();//通知写日志的那个家伙，干活啦
                        Thread.Sleep(rnd.Next(100) + 2);//休息一会儿
                    }
                });
            }
            try
            {
                Task.WaitAll(waitingTask);//我是老板，我在看着他们干活
            }
            catch (AggregateException ex)
            {
                ex.Flatten().Handle((inner) =>
                {
                    Console.WriteLine("Exception is {0}", inner.Message);
                    return true;
                });
            }
            Console.WriteLine("Press enter to finish");
            Console.ReadLine();
        }
```
